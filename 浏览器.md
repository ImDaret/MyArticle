---
title: 【学习笔记】浏览器篇
---

# 一、多进程架构
1. 浏览器进程:负责界面展示，用户交互，子进程管理，提供存储功能
2. 渲染进程：将html，css，js解析，出于安全，渲染进程运行在沙箱之下
3. GPU进程：为了实现3D CSS效果，
4. 网络进程：负责页面网络资源的加载
5. 插件进程：负责插件的运行，保证插件的奔溃不会对浏览器和页面造成影响

# 二、TCP协议

## TCP的生命周期
1. 三次握手建立连接
2. 传输数据阶段
3. 四次挥手断开连接

## 三次握手
1. 客户端向服务端发送SYN，同时带上序列号ISN
2. 服务端返回ACK（序号为ISN+1），同时向客户端发送SYN
3. 客户端向服务端发送ACK确认收到（序列号为服务端序列号+1）

## 四次挥手
1. 主动关闭的一方发送FIN，表示要单方面关闭数据的传输
2. 被动的一方收到FIN后，发送一个ACK确认（序列号为收到的序列号+1）
3. 等数据传输完毕，被动的一方再发送一个FIN标识，表示关闭这个方向的数据传输
4. 主动方回复ACK确认回复

# 三、HTTP协议

## 浏览器端发起HTTP请求的流程
1. 构建请求：请求行信息
2. 查找缓存:如果有则直接返回副本，如果没有就去服务器重新下载
3. 等待TCP队列：一个域名最多建立6个TCP
4. 建立TCP连接：三次握手
5. 发起HTTP请求：见下面
6. 服务器处理请求：处理请求过程
7. 服务器响应请求：见下面
8. 渲染进程开始工作
9. 断开TCP连接：四次挥手

## 客户端发起HTTP请求
1. 请求行：请求方法，请求URL，HTTP协议版本
2. 请求头：见下面
3. 请求体：携带的数据，一般get请求为空

## 服务端响应请求
1. 响应行：HTTP协议版本,状态码
2. 响应头：见下面
3. 响应体：返回要请求的数据

## 常用通用头部字段
1. cache-control:控制缓存的方式
2. connection:优先使用的连接类型
3. date：创建报文的时间
4. transfer-encoding：传输的编码方式,chunked为分块传输
5. content-encoding:内容的编码格式
6. content-language:内容使用的语言
7. content-location:返回数据的备用地址
8. content-type：内容的媒体类型
9. expires：内容的过期时间

## 常用请求头部字段
1. accept:能正确接收的媒体类型
2. accept-encoding:能正确接收的编码格式列表
3. accept-language:能正确接收的语言列表
4. authorization:客户端的认证信息，一般存token用
5. cookie:发送给服务器的缓存信息
6. host:服务器域名
7. referer:请求发起页面的原始URL

## 常用响应头部字段
1. accept-ranges:告知客户端服务器是否可以接受范围请求，是bytes,否none
2. age:资源在代理缓存中存在的时间
3. etag：资源标识，资源发生变化时标识也会发生变化
4. location：客户端重定向到某个URL
5. server：服务器的名字
6. set-cookie：存给客户端的信息，一般用于识别用户身份

## 状态码
2xx代表成功，3xx代表重定向，4xx代表客户端错误，5xx代表服务器错误
1. 200:ok
2. 204:请求成功，但是响应报文没有主体部分
3. 206:进行范围请求成功
4. 301:永久性重定向
5. 302:临时重定向
6. 303:资源存在另一个URL，使用Get方法获取资源
7. 304：请求没有满足条件
8. 400:请求报文存在语法错误
9. 401:发送的请求需要有HTTP认证的信息
10. 403:请求资源的访问被服务器拒绝
11. 404:在服务器上没有找到请求资源
12. 500：服务端在执行请求是发生了错误
13. 501：服务器不支持当前请求所需要的某个功能
14. 503：服务器当前处于超负载或正在停机维护，无法处理请求

# 四、完整的渲染进程
1. 渲染进程将HTML内容转换为能够读懂的DOM树结构
2. 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets
3. 创建布局树，计算元素的布局信息
4. 对布局树进行分层，并生成分层树
5. 为每个图层绘制列表，提交到合成线程
6. 合成线程将图层分为图块，并在光栅化线程池中将图块转换为位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

# 五、垃圾回收

## 栈中的数据是如何被回收的
当一个函数执行完毕之后，ESP指针下移来销毁该函数保存在栈中的执行上下文

## 堆中的数据是如何被回收的
1. 首先将堆空间分为新生区（副垃圾回收器控制）和老生区（主垃圾回收器控制）
2. 再把新生区分为对象区域和空闲区域
3. 新加入的对象会进入对象区域，当对象区域快写满时，需要执行一次垃圾清理
4. 先对对象区域的中的垃圾做个标记，副垃圾回收器将对象区域的存活对象复制进空闲区域并进行有序排列（相当于整理）
5. 完成复制后，将对象区域和空闲区域进行翻转
6. 如果翻转依然还存活的对象就进入老生区
7. 老生区有两种对象，一种是新生区过来的，另一种是自身很大，会被直接分配到老生区
8. 主垃圾回收器采取标记-清除，清除之后会产生大量的不连续的内存碎片
9. 所以后面采取标记-整理，让所有存存活对象都向一端移动

## 缺点
因为JS是单线程的，所以一旦执行垃圾回收算法就会导致其他脚本暂停，称之为全停顿

## 改进
采用增量标记算法，把一个完整的垃圾回收任务分为很多小的任务，穿插在其他JavaScript任务中间执行

# 六、V8是如何执行JavaScript代码的
采用了“字节码+JIT”的技术
1. 将JS代码转换为字节码
2. 判断是否为热区代码
3. 如果不是就给Ignition解释器逐条解释执行输出结果
4. 如果是就给JIT编译器转换为机器码输出结果

# 七、HTTP1，HTTP2，HTTP3的过程

## HTTP1
1. 增加了持久连接
2. 每个域名最多同时维护6个TCP连接
3. 使用CDN实现域名分片机制
但是它也有缺点：TCP慢启动，多条TCP竞争带宽和队头阻塞

## HTTP2
1. 采用多路复用机制，通过设置二进制分帧层实现请求的优先级，服务器推送，头部压缩等 
但是HTTP2用的还是TCP协议，所以还会存在队头阻塞问题

## HTTP3
1.采用QUIC协议，集成了TCP+多路复用+TLS安全加密等功能，然后使用UDP协议提升传输速度，但是由于生态环境不好，对UDP的优化不行导致还有很长的路要走

# 八、XSS和CSRF攻击

## XSS攻击
1. 概念：XSS攻击是一种代码注入攻击，其本质是恶意代码未经过滤和网站正常的代码混在一起
2. 解决方案: 服务器对输入脚本进行过滤或者转码或者可以使用HTTPonly，只能HTTP请求获得cookie，JS获取不到

## CSRF攻击
1. 概念：CSRF攻击是一种跨站请求伪造的攻击，攻击者登录了存在CSRF漏洞的网站A，此时生成了cookie，然后再没有退出网站A的情况下，诱导其访问B网站，B携带着cookie背着受害者偷偷的发起一个请求
2.解决方案：
利用samesite cookie属性，同站的cookie只能作为第一方的cookie不能作为第三方cookie

判断来源，检测referer来判断请求的来源是否安全

利用token，服务端给用户生成一个token，然后在提交请求的时候需要验证这个token是否正确

# 九、HTTPS
HTTPS在HTTP和TCP之间加了一个安全层

## 对称加密
用同一个钥匙加密解密,速度快

## 非对称加密
利用公钥加密，私钥解密，有一定安全性

## 对称加密和非对称加密
1. 发送方利用对方的公钥进行加密处理得到“对称密钥”
2. 接收方利用自己的私钥进行处理得到（“对称密钥”）
3， 双方通过这个对称密钥进行通信

## 如何验证数字证书（解决报文可能被篡改的问题）
1. 报文通过Hash函数得到信息摘要，再用CA私钥加密得到数字签名
2. 直接利用Hash函数对报文处理得到信息摘要A
3. 再利用对应CA的公钥签名解密数字签名，得到信息摘要B
4. 如果信息A和信息B一致，那就确认证书是合法的

## HTTPS和HTTP的区别
1. HTTPS更加安全
2. HTTP需要用到SSL证书
3. HTTPS的标准端口是443，HTTP的标准端口是80
4. HTTPS基于传输层，HTTP基于应用层